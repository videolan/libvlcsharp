// ----------------------------------------------------------------------------
// <auto-generated>
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
// </auto-generated>
// ----------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;
using System.Security;

namespace VideoLAN.LibVLC
{
    /// <summary>
    /// <para>LibVLC renderer discoverer finds available renderers available on the local</para>
    /// <para>network</para>
    /// <para>@{</para>
    /// <para></para>
    /// <para>LibVLC renderer discoverer external API</para>
    /// </summary>
    /// <summary>Renderer item</summary>
    /// <remarks>
    /// <para>This struct is passed by a</para>
    /// <para>or deleted.</para>
    /// <para>An item is valid until the</para>
    /// <para>is called with the same pointer.</para>
    /// <para>libvlc_renderer_discoverer_event_manager()</para>
    /// </remarks>
    public unsafe partial class RendererItem
    {
        [StructLayout(LayoutKind.Explicit, Size = 0)]
        public partial struct __Internal
        {
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VideoLAN.LibVLC.RendererItem> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VideoLAN.LibVLC.RendererItem>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::VideoLAN.LibVLC.RendererItem __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::VideoLAN.LibVLC.RendererItem(native.ToPointer(), skipVTables);
        }

        internal static global::VideoLAN.LibVLC.RendererItem __CreateInstance(global::VideoLAN.LibVLC.RendererItem.__Internal native, bool skipVTables = false)
        {
            return new global::VideoLAN.LibVLC.RendererItem(native, skipVTables);
        }

        private static void* __CopyValue(global::VideoLAN.LibVLC.RendererItem.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::VideoLAN.LibVLC.RendererItem.__Internal));
            *(global::VideoLAN.LibVLC.RendererItem.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private RendererItem(global::VideoLAN.LibVLC.RendererItem.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected RendererItem(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }
    }

    public unsafe partial class RendererDiscoverer
    {
        [StructLayout(LayoutKind.Explicit, Size = 0)]
        public partial struct __Internal
        {
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VideoLAN.LibVLC.RendererDiscoverer> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VideoLAN.LibVLC.RendererDiscoverer>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::VideoLAN.LibVLC.RendererDiscoverer __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::VideoLAN.LibVLC.RendererDiscoverer(native.ToPointer(), skipVTables);
        }

        internal static global::VideoLAN.LibVLC.RendererDiscoverer __CreateInstance(global::VideoLAN.LibVLC.RendererDiscoverer.__Internal native, bool skipVTables = false)
        {
            return new global::VideoLAN.LibVLC.RendererDiscoverer(native, skipVTables);
        }

        private static void* __CopyValue(global::VideoLAN.LibVLC.RendererDiscoverer.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::VideoLAN.LibVLC.RendererDiscoverer.__Internal));
            *(global::VideoLAN.LibVLC.RendererDiscoverer.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private RendererDiscoverer(global::VideoLAN.LibVLC.RendererDiscoverer.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected RendererDiscoverer(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }
    }

    /// <summary>Renderer discoverer description</summary>
    /// <remarks>libvlc_renderer_discoverer_list_get()</remarks>
    public unsafe partial class RendererDiscovererDescription : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 16)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr psz_name;

            [FieldOffset(8)]
            internal global::System.IntPtr psz_longname;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0libvlc_rd_description_t@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VideoLAN.LibVLC.RendererDiscovererDescription> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VideoLAN.LibVLC.RendererDiscovererDescription>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::VideoLAN.LibVLC.RendererDiscovererDescription __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::VideoLAN.LibVLC.RendererDiscovererDescription(native.ToPointer(), skipVTables);
        }

        internal static global::VideoLAN.LibVLC.RendererDiscovererDescription __CreateInstance(global::VideoLAN.LibVLC.RendererDiscovererDescription.__Internal native, bool skipVTables = false)
        {
            return new global::VideoLAN.LibVLC.RendererDiscovererDescription(native, skipVTables);
        }

        private static void* __CopyValue(global::VideoLAN.LibVLC.RendererDiscovererDescription.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::VideoLAN.LibVLC.RendererDiscovererDescription.__Internal));
            *(global::VideoLAN.LibVLC.RendererDiscovererDescription.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private RendererDiscovererDescription(global::VideoLAN.LibVLC.RendererDiscovererDescription.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected RendererDiscovererDescription(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public RendererDiscovererDescription()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::VideoLAN.LibVLC.RendererDiscovererDescription.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public RendererDiscovererDescription(global::VideoLAN.LibVLC.RendererDiscovererDescription _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::VideoLAN.LibVLC.RendererDiscovererDescription.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::VideoLAN.LibVLC.RendererDiscovererDescription.__Internal*) __Instance) = *((global::VideoLAN.LibVLC.RendererDiscovererDescription.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::VideoLAN.LibVLC.RendererDiscovererDescription __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public sbyte* PszName
        {
            get
            {
                return (sbyte*) ((global::VideoLAN.LibVLC.RendererDiscovererDescription.__Internal*) __Instance)->psz_name;
            }

            set
            {
                ((global::VideoLAN.LibVLC.RendererDiscovererDescription.__Internal*) __Instance)->psz_name = (global::System.IntPtr) value;
            }
        }

        public sbyte* PszLongname
        {
            get
            {
                return (sbyte*) ((global::VideoLAN.LibVLC.RendererDiscovererDescription.__Internal*) __Instance)->psz_longname;
            }

            set
            {
                ((global::VideoLAN.LibVLC.RendererDiscovererDescription.__Internal*) __Instance)->psz_longname = (global::System.IntPtr) value;
            }
        }
    }

    public unsafe partial class libvlc_renderer_discoverer
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_renderer_item_name")]
            internal static extern global::System.IntPtr LibvlcRendererItemName(global::System.IntPtr p_item);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_renderer_item_type")]
            internal static extern global::System.IntPtr LibvlcRendererItemType(global::System.IntPtr p_item);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_renderer_item_icon_uri")]
            internal static extern global::System.IntPtr LibvlcRendererItemIconUri(global::System.IntPtr p_item);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_renderer_item_flags")]
            internal static extern int LibvlcRendererItemFlags(global::System.IntPtr p_item);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_renderer_discoverer_new")]
            internal static extern global::System.IntPtr LibvlcRendererDiscovererNew(global::System.IntPtr p_inst, [MarshalAs(UnmanagedType.LPStr)] string psz_name);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_renderer_discoverer_release")]
            internal static extern void LibvlcRendererDiscovererRelease(global::System.IntPtr p_rd);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_renderer_discoverer_start")]
            internal static extern int LibvlcRendererDiscovererStart(global::System.IntPtr p_rd);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_renderer_discoverer_stop")]
            internal static extern void LibvlcRendererDiscovererStop(global::System.IntPtr p_rd);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_renderer_discoverer_event_manager")]
            internal static extern global::System.IntPtr LibvlcRendererDiscovererEventManager(global::System.IntPtr p_rd);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_renderer_discoverer_list_get")]
            internal static extern ulong LibvlcRendererDiscovererListGet(global::System.IntPtr p_inst, global::System.IntPtr ppp_services);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="libvlc_renderer_discoverer_list_release")]
            internal static extern void LibvlcRendererDiscovererListRelease(global::System.IntPtr pp_services, ulong i_count);
        }

        /// <summary>Get the human readable name of a renderer item</summary>
        /// <returns>the name of the item (can't be NULL, must *not* be freed)</returns>
        /// <remarks>LibVLC 3.0.0 or later</remarks>
        public static string LibvlcRendererItemName(global::VideoLAN.LibVLC.RendererItem p_item)
        {
            var __arg0 = ReferenceEquals(p_item, null) ? global::System.IntPtr.Zero : p_item.__Instance;
            var __ret = __Internal.LibvlcRendererItemName(__arg0);
            return Marshal.PtrToStringAnsi(__ret);
        }

        /// <summary>
        /// <para>Get the type (not translated) of a renderer item. For now, the type can only</para>
        /// <para>be &quot;chromecast&quot; (&quot;upnp&quot;, &quot;airplay&quot; may come later).</para>
        /// </summary>
        /// <returns>the type of the item (can't be NULL, must *not* be freed)</returns>
        /// <remarks>LibVLC 3.0.0 or later</remarks>
        public static string LibvlcRendererItemType(global::VideoLAN.LibVLC.RendererItem p_item)
        {
            var __arg0 = ReferenceEquals(p_item, null) ? global::System.IntPtr.Zero : p_item.__Instance;
            var __ret = __Internal.LibvlcRendererItemType(__arg0);
            return Marshal.PtrToStringAnsi(__ret);
        }

        /// <summary>Get the icon uri of a renderer item</summary>
        /// <returns>the uri of the item's icon (can be NULL, must *not* be freed)</returns>
        /// <remarks>LibVLC 3.0.0 or later</remarks>
        public static string LibvlcRendererItemIconUri(global::VideoLAN.LibVLC.RendererItem p_item)
        {
            var __arg0 = ReferenceEquals(p_item, null) ? global::System.IntPtr.Zero : p_item.__Instance;
            var __ret = __Internal.LibvlcRendererItemIconUri(__arg0);
            return Marshal.PtrToStringAnsi(__ret);
        }

        /// <summary>Get the flags of a renderer item</summary>
        /// <returns>bitwise flag: capabilities of the renderer, see</returns>
        /// <remarks>
        /// <para>LIBVLC_RENDERER_CAN_AUDIO</para>
        /// <para>LIBVLC_RENDERER_CAN_VIDEO</para>
        /// <para>LibVLC 3.0.0 or later</para>
        /// </remarks>
        public static int LibvlcRendererItemFlags(global::VideoLAN.LibVLC.RendererItem p_item)
        {
            var __arg0 = ReferenceEquals(p_item, null) ? global::System.IntPtr.Zero : p_item.__Instance;
            var __ret = __Internal.LibvlcRendererItemFlags(__arg0);
            return __ret;
        }

        /// <summary>Create a renderer discoverer object by name</summary>
        /// <param name="p_inst">libvlc instance</param>
        /// <param name="psz_name">
        /// <para>service name; use libvlc_renderer_discoverer_list_get() to</para>
        /// <para>get a list of the discoverer names available in this libVLC instance</para>
        /// </param>
        /// <returns>media discover object or NULL in case of error</returns>
        /// <remarks>
        /// <para>After this object is created, you should attach to events in order to be</para>
        /// <para>notified of the discoverer events.</para>
        /// <para>You need to call libvlc_renderer_discoverer_start() in order to start the</para>
        /// <para>discovery.</para>
        /// <para>libvlc_renderer_discoverer_event_manager()</para>
        /// <para>libvlc_renderer_discoverer_start()</para>
        /// <para>LibVLC 3.0.0 or later</para>
        /// </remarks>
        public static global::VideoLAN.LibVLC.RendererDiscoverer LibvlcRendererDiscovererNew(global::VideoLAN.LibVLC.Manual.Instance p_inst, string psz_name)
        {
            var __arg0 = ReferenceEquals(p_inst, null) ? global::System.IntPtr.Zero : p_inst.NativeReference;
            var __ret = __Internal.LibvlcRendererDiscovererNew(__arg0, psz_name);
            global::VideoLAN.LibVLC.RendererDiscoverer __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::VideoLAN.LibVLC.RendererDiscoverer.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::VideoLAN.LibVLC.RendererDiscoverer) global::VideoLAN.LibVLC.RendererDiscoverer.NativeToManagedMap[__ret];
            else __result0 = global::VideoLAN.LibVLC.RendererDiscoverer.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>Release a renderer discoverer object</summary>
        /// <param name="p_rd">renderer discoverer object</param>
        /// <remarks>LibVLC 3.0.0 or later</remarks>
        public static void LibvlcRendererDiscovererRelease(global::VideoLAN.LibVLC.RendererDiscoverer p_rd)
        {
            var __arg0 = ReferenceEquals(p_rd, null) ? global::System.IntPtr.Zero : p_rd.__Instance;
            __Internal.LibvlcRendererDiscovererRelease(__arg0);
        }

        /// <summary>Start renderer discovery</summary>
        /// <param name="p_rd">renderer discoverer object</param>
        /// <returns>-1 in case of error, 0 otherwise</returns>
        /// <remarks>
        /// <para>To stop it, call libvlc_renderer_discoverer_stop() or</para>
        /// <para>libvlc_renderer_discoverer_release() directly.</para>
        /// <para>libvlc_renderer_discoverer_stop()</para>
        /// <para>LibVLC 3.0.0 or later</para>
        /// </remarks>
        public static int LibvlcRendererDiscovererStart(global::VideoLAN.LibVLC.RendererDiscoverer p_rd)
        {
            var __arg0 = ReferenceEquals(p_rd, null) ? global::System.IntPtr.Zero : p_rd.__Instance;
            var __ret = __Internal.LibvlcRendererDiscovererStart(__arg0);
            return __ret;
        }

        /// <summary>Stop renderer discovery.</summary>
        /// <param name="p_rd">renderer discoverer object</param>
        /// <remarks>
        /// <para>libvlc_renderer_discoverer_start()</para>
        /// <para>LibVLC 3.0.0 or later</para>
        /// </remarks>
        public static void LibvlcRendererDiscovererStop(global::VideoLAN.LibVLC.RendererDiscoverer p_rd)
        {
            var __arg0 = ReferenceEquals(p_rd, null) ? global::System.IntPtr.Zero : p_rd.__Instance;
            __Internal.LibvlcRendererDiscovererStop(__arg0);
        }

        /// <summary>Get the event manager of the renderer discoverer</summary>
        /// <returns>a valid event manager (can't fail)</returns>
        /// <remarks>
        /// <para>The possible events to attach are</para>
        /// <para>and</para>
        /// <para>The</para>
        /// <para>VLC, users should take care of copying this struct for their internal usage.</para>
        /// <para>libvlc_event_t.u.renderer_discoverer_item_added.item</para>
        /// <para>libvlc_event_t.u.renderer_discoverer_item_removed.item</para>
        /// <para>LibVLC 3.0.0 or later</para>
        /// </remarks>
        //public static global::VideoLAN.LibVLC.EventManager LibvlcRendererDiscovererEventManager(global::VideoLAN.LibVLC.RendererDiscoverer p_rd)
        //{
        //    var __arg0 = ReferenceEquals(p_rd, null) ? global::System.IntPtr.Zero : p_rd.NativeReference;
        //    var __ret = __Internal.LibvlcRendererDiscovererEventManager(__arg0);
        //    global::VideoLAN.LibVLC.EventManager __result0;
        //    if (__ret == IntPtr.Zero) __result0 = null;
        //    else if (global::VideoLAN.LibVLC.EventManager.NativeToManagedMap.ContainsKey(__ret))
        //        __result0 = (global::VideoLAN.LibVLC.EventManager) global::VideoLAN.LibVLC.EventManager.NativeToManagedMap[__ret];
        //    else __result0 = global::VideoLAN.LibVLC.EventManager.__CreateInstance(__ret);
        //    return __result0;
        //}

        /// <summary>Get media discoverer services</summary>
        /// <param name="p_inst">libvlc instance</param>
        /// <param name="ppp_services">
        /// <para>address to store an allocated array of renderer</para>
        /// <para>discoverer services (must be freed with libvlc_renderer_list_release() by</para>
        /// <para>the caller) [OUT]</para>
        /// </param>
        /// <returns>the number of media discoverer services (0 on error)</returns>
        /// <remarks>
        /// <para>libvlc_renderer_list_release()</para>
        /// <para>LibVLC 3.0.0 and later</para>
        /// </remarks>
        public static ulong LibvlcRendererDiscovererListGet(global::VideoLAN.LibVLC.Manual.Instance p_inst, global::VideoLAN.LibVLC.RendererDiscovererDescription ppp_services)
        {
            var __arg0 = ReferenceEquals(p_inst, null) ? global::System.IntPtr.Zero : p_inst.NativeReference;
            var __arg1 = ReferenceEquals(ppp_services, null) ? global::System.IntPtr.Zero : ppp_services.__Instance;
            var __ret = __Internal.LibvlcRendererDiscovererListGet(__arg0, __arg1);
            return __ret;
        }

        /// <summary>Release an array of media discoverer services</summary>
        /// <param name="pp_services">array to release</param>
        /// <param name="i_count">number of elements in the array</param>
        /// <remarks>
        /// <para>libvlc_renderer_discoverer_list_get()</para>
        /// <para>LibVLC 3.0.0 and later</para>
        /// </remarks>
        public static void LibvlcRendererDiscovererListRelease(global::VideoLAN.LibVLC.RendererDiscovererDescription pp_services, ulong i_count)
        {
            var __arg0 = ReferenceEquals(pp_services, null) ? global::System.IntPtr.Zero : pp_services.__Instance;
            __Internal.LibvlcRendererDiscovererListRelease(__arg0, i_count);
        }
    }
}
