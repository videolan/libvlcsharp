// ----------------------------------------------------------------------------
// <auto-generated>
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
// </auto-generated>
// ----------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;
using System.Security;

namespace VideoLAN.LibVLC
{
    /// <summary>This structure is opaque. It represents a libvlc log iterator</summary>
    public unsafe partial class LogIterator
    {
        [StructLayout(LayoutKind.Explicit, Size = 0)]
        public partial struct __Internal
        {
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;

        internal static readonly
            global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VideoLAN.LibVLC.LogIterator>
            NativeToManagedMap =
                new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VideoLAN.LibVLC.LogIterator
                >();

        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::VideoLAN.LibVLC.LogIterator __CreateInstance(global::System.IntPtr native,
            bool skipVTables = false)
        {
            return new global::VideoLAN.LibVLC.LogIterator(native.ToPointer(), skipVTables);
        }

        internal static global::VideoLAN.LibVLC.LogIterator __CreateInstance(
            global::VideoLAN.LibVLC.LogIterator.__Internal native, bool skipVTables = false)
        {
            return new global::VideoLAN.LibVLC.LogIterator(native, skipVTables);
        }

        private static void* __CopyValue(global::VideoLAN.LibVLC.LogIterator.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::VideoLAN.LibVLC.LogIterator.__Internal));
            *(global::VideoLAN.LibVLC.LogIterator.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private LogIterator(global::VideoLAN.LibVLC.LogIterator.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected LogIterator(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }
    }

    public unsafe partial class LogMessage : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 40)]
        public partial struct __Internal
        {
            [FieldOffset(0)] internal int i_severity;

            [FieldOffset(8)] internal global::System.IntPtr psz_type;

            [FieldOffset(16)] internal global::System.IntPtr psz_name;

            [FieldOffset(24)] internal global::System.IntPtr psz_header;

            [FieldOffset(32)] internal global::System.IntPtr psz_message;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint = "??0libvlc_log_message_t@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr
                cctor(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;

        internal static readonly
            global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VideoLAN.LibVLC.LogMessage>
            NativeToManagedMap =
                new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VideoLAN.LibVLC.LogMessage>()
            ;

        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::VideoLAN.LibVLC.LogMessage __CreateInstance(global::System.IntPtr native,
            bool skipVTables = false)
        {
            return new global::VideoLAN.LibVLC.LogMessage(native.ToPointer(), skipVTables);
        }

        internal static global::VideoLAN.LibVLC.LogMessage __CreateInstance(
            global::VideoLAN.LibVLC.LogMessage.__Internal native, bool skipVTables = false)
        {
            return new global::VideoLAN.LibVLC.LogMessage(native, skipVTables);
        }

        private static void* __CopyValue(global::VideoLAN.LibVLC.LogMessage.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::VideoLAN.LibVLC.LogMessage.__Internal));
            *(global::VideoLAN.LibVLC.LogMessage.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private LogMessage(global::VideoLAN.LibVLC.LogMessage.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected LogMessage(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public LogMessage()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::VideoLAN.LibVLC.LogMessage.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public LogMessage(global::VideoLAN.LibVLC.LogMessage _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::VideoLAN.LibVLC.LogMessage.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::VideoLAN.LibVLC.LogMessage.__Internal*) __Instance) =
                *((global::VideoLAN.LibVLC.LogMessage.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::VideoLAN.LibVLC.LogMessage __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int ISeverity
        {
            get { return ((global::VideoLAN.LibVLC.LogMessage.__Internal*) __Instance)->i_severity; }

            set { ((global::VideoLAN.LibVLC.LogMessage.__Internal*) __Instance)->i_severity = value; }
        }

        public string PszType
        {
            get { return Marshal.PtrToStringAnsi(((global::VideoLAN.LibVLC.LogMessage.__Internal*) __Instance)->psz_type); }

            set
            {
                ((global::VideoLAN.LibVLC.LogMessage.__Internal*) __Instance)->psz_type =
                    Marshal.StringToHGlobalAnsi(value);
            }
        }

        public string PszName
        {
            get { return Marshal.PtrToStringAnsi(((global::VideoLAN.LibVLC.LogMessage.__Internal*) __Instance)->psz_name); }

            set
            {
                ((global::VideoLAN.LibVLC.LogMessage.__Internal*) __Instance)->psz_name =
                    Marshal.StringToHGlobalAnsi(value);
            }
        }

        public string PszHeader
        {
            get
            {
                return Marshal.PtrToStringAnsi(((global::VideoLAN.LibVLC.LogMessage.__Internal*) __Instance)->psz_header);
            }

            set
            {
                ((global::VideoLAN.LibVLC.LogMessage.__Internal*) __Instance)->psz_header =
                    Marshal.StringToHGlobalAnsi(value);
            }
        }

        public string PszMessage
        {
            get
            {
                return Marshal.PtrToStringAnsi(((global::VideoLAN.LibVLC.LogMessage.__Internal*) __Instance)->psz_message);
            }

            set
            {
                ((global::VideoLAN.LibVLC.LogMessage.__Internal*) __Instance)->psz_message =
                    Marshal.StringToHGlobalAnsi(value);
            }
        }
    }

    public unsafe partial class deprecated
    {
        public partial struct __Internal
        {
           

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint = "libvlc_media_player_set_agl")]
            internal static extern void LibvlcMediaPlayerSetAgl(global::System.IntPtr p_mi, uint drawable);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint = "libvlc_media_player_get_agl")]
            internal static extern uint LibvlcMediaPlayerGetAgl(global::System.IntPtr p_mi);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint = "libvlc_track_description_release")]
            internal static extern void LibvlcTrackDescriptionRelease(global::System.IntPtr p_track_description);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint = "libvlc_video_get_height")]
            internal static extern int LibvlcVideoGetHeight(global::System.IntPtr p_mi);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint = "libvlc_video_get_width")]
            internal static extern int LibvlcVideoGetWidth(global::System.IntPtr p_mi);


            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint = "libvlc_audio_output_device_count")]
            internal static extern int LibvlcAudioOutputDeviceCount(global::System.IntPtr p_instance,
                [MarshalAs(UnmanagedType.LPStr)] string psz_audio_output);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint = "libvlc_audio_output_device_longname")]
            internal static extern sbyte* LibvlcAudioOutputDeviceLongname(global::System.IntPtr p_instance,
                [MarshalAs(UnmanagedType.LPStr)] string psz_output, int i_device);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint = "libvlc_audio_output_device_id")]
            internal static extern sbyte* LibvlcAudioOutputDeviceId(global::System.IntPtr p_instance,
                [MarshalAs(UnmanagedType.LPStr)] string psz_audio_output, int i_device);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint = "libvlc_audio_output_get_device_type")]
            internal static extern int LibvlcAudioOutputGetDeviceType(global::System.IntPtr p_mi);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint = "libvlc_audio_output_set_device_type")]
            internal static extern void LibvlcAudioOutputSetDeviceType(global::System.IntPtr p_mp, int device_type);

            

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint = "libvlc_media_get_tracks_info")]
            internal static extern int LibvlcMediaGetTracksInfo(global::System.IntPtr p_md,
                global::System.IntPtr tracks);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint = "libvlc_media_list_add_file_content")]
            internal static extern int LibvlcMediaListAddFileContent(global::System.IntPtr p_ml,
                [MarshalAs(UnmanagedType.LPStr)] string psz_uri);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint = "libvlc_media_discoverer_new_from_name")]
            internal static extern global::System.IntPtr LibvlcMediaDiscovererNewFromName(global::System.IntPtr p_inst,
                [MarshalAs(UnmanagedType.LPStr)] string psz_name);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint = "libvlc_media_discoverer_localized_name")]
            internal static extern sbyte* LibvlcMediaDiscovererLocalizedName(global::System.IntPtr p_mdis);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint = "libvlc_media_discoverer_event_manager")]
            internal static extern global::System.IntPtr
                LibvlcMediaDiscovererEventManager(global::System.IntPtr p_mdis);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint = "libvlc_wait")]
            internal static extern void LibvlcWait(global::System.IntPtr p_instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint = "libvlc_get_log_verbosity")]
            internal static extern uint LibvlcGetLogVerbosity(global::System.IntPtr p_instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint = "libvlc_set_log_verbosity")]
            internal static extern void LibvlcSetLogVerbosity(global::System.IntPtr p_instance, uint level);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint = "libvlc_log_open")]
            internal static extern global::System.IntPtr LibvlcLogOpen(global::System.IntPtr p_instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint = "libvlc_log_close")]
            internal static extern void LibvlcLogClose(global::System.IntPtr p_log);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint = "libvlc_log_count")]
            internal static extern uint LibvlcLogCount(global::System.IntPtr p_log);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint = "libvlc_log_clear")]
            internal static extern void LibvlcLogClear(global::System.IntPtr p_log);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint = "libvlc_log_get_iterator")]
            internal static extern global::System.IntPtr LibvlcLogGetIterator(global::System.IntPtr p_log);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint = "libvlc_log_iterator_free")]
            internal static extern void LibvlcLogIteratorFree(global::System.IntPtr p_iter);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint = "libvlc_log_iterator_has_next")]
            internal static extern int LibvlcLogIteratorHasNext(global::System.IntPtr p_iter);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint = "libvlc_log_iterator_next")]
            internal static extern global::System.IntPtr LibvlcLogIteratorNext(global::System.IntPtr p_iter,
                global::System.IntPtr p_buf);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("libvlc", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint = "libvlc_playlist_play")]
            internal static extern void LibvlcPlaylistPlay(global::System.IntPtr p_instance, int i_id, int i_options,
                sbyte** ppsz_options);
        }

        /// <summary>Get movie fps rate</summary>
        /// <param name="p_mi">the Media Player</param>
        /// <returns>frames per second (fps) for this playing movie, or 0 if unspecified</returns>
        /// <remarks>
        /// <para>This function is provided for backward compatibility. It cannot deal with</para>
        /// <para>multiple video tracks. In LibVLC versions prior to 3.0, it would also fail</para>
        /// <para>if the file format did not convey the frame rate explicitly.</para>
        /// <para>Consider using libvlc_media_tracks_get() instead.</para>
        /// </remarks>
        //public static float LibvlcMediaPlayerGetFps(global::VideoLAN.LibVLC.MediaPlayer p_mi)
        //{
        //    var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.NativeReference;
        //    var __ret = __Internal.LibvlcMediaPlayerGetFps(__arg0);
        //    return __ret;
        //}

        /// <remarks>Use libvlc_media_player_set_nsobject() instead</remarks>
        //public static void LibvlcMediaPlayerSetAgl(global::VideoLAN.LibVLC.MediaPlayer p_mi, uint drawable)
        //{
        //    var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.__Instance;
        //    __Internal.LibvlcMediaPlayerSetAgl(__arg0, drawable);
        //}

        ///// <remarks>Use libvlc_media_player_get_nsobject() instead</remarks>
        //public static uint LibvlcMediaPlayerGetAgl(global::VideoLAN.LibVLC.MediaPlayer p_mi)
        //{
        //    var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.__Instance;
        //    var __ret = __Internal.LibvlcMediaPlayerGetAgl(__arg0);
        //    return __ret;
        //}

        /// <remarks>Use libvlc_track_description_list_release() instead</remarks>
        public static void LibvlcTrackDescriptionRelease(global::VideoLAN.LibVLC.TrackDescription p_track_description)
        {
            var __arg0 = ReferenceEquals(p_track_description, null)
                ? global::System.IntPtr.Zero
                : p_track_description.__Instance;
            __Internal.LibvlcTrackDescriptionRelease(__arg0);
        }

        /// <summary>Get current video height.</summary>
        /// <param name="p_mi">the media player</param>
        /// <returns>the video pixel height or 0 if not applicable</returns>
        /// <remarks>Use libvlc_video_get_size() instead.</remarks>
        //public static int LibvlcVideoGetHeight(global::VideoLAN.LibVLC.MediaPlayer p_mi)
        //{
        //    var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.__Instance;
        //    var __ret = __Internal.LibvlcVideoGetHeight(__arg0);
        //    return __ret;
        //}

        /// <summary>Get current video width.</summary>
        /// <param name="p_mi">the media player</param>
        /// <returns>the video pixel width or 0 if not applicable</returns>
        /// <remarks>Use libvlc_video_get_size() instead.</remarks>
        //public static int LibvlcVideoGetWidth(global::VideoLAN.LibVLC.MediaPlayer p_mi)
        //{
        //    var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.__Instance;
        //    var __ret = __Internal.LibvlcVideoGetWidth(__arg0);
        //    return __ret;
        //}

        /// <summary>Get the description of available titles.</summary>
        /// <param name="p_mi">the media player</param>
        /// <returns>
        /// <para>list containing description of available titles.</para>
        /// <para>It must be freed with libvlc_track_description_list_release()</para>
        /// </returns>
        //public static global::VideoLAN.LibVLC.TrackDescription LibvlcVideoGetTitleDescription(
        //    global::VideoLAN.LibVLC.MediaPlayer p_mi)
        //{
        //    var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.NativeReference;
        //    var __ret = __Internal.LibvlcVideoGetTitleDescription(__arg0);
        //    global::VideoLAN.LibVLC.TrackDescription __result0;
        //    if (__ret == IntPtr.Zero) __result0 = null;
        //    else if (global::VideoLAN.LibVLC.TrackDescription.NativeToManagedMap.ContainsKey(__ret))
        //        __result0 = (global::VideoLAN.LibVLC.TrackDescription) global::VideoLAN.LibVLC.TrackDescription
        //            .NativeToManagedMap[__ret];
        //    else __result0 = global::VideoLAN.LibVLC.TrackDescription.__CreateInstance(__ret);
        //    return __result0;
        //}

        /// <summary>Get the description of available chapters for specific title.</summary>
        /// <param name="p_mi">the media player</param>
        /// <param name="i_title">selected title</param>
        /// <returns>
        /// <para>list containing description of available chapter for title i_title.</para>
        /// <para>It must be freed with libvlc_track_description_list_release()</para>
        /// </returns>
        //public static global::VideoLAN.LibVLC.TrackDescription LibvlcVideoGetChapterDescription(
        //    global::VideoLAN.LibVLC.MediaPlayer p_mi, int i_title)
        //{
        //    var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.NativeReference;
        //    var __ret = __Internal.LibvlcVideoGetChapterDescription(__arg0, i_title);
        //    global::VideoLAN.LibVLC.TrackDescription __result0;
        //    if (__ret == IntPtr.Zero) __result0 = null;
        //    else if (global::VideoLAN.LibVLC.TrackDescription.NativeToManagedMap.ContainsKey(__ret))
        //        __result0 = (global::VideoLAN.LibVLC.TrackDescription) global::VideoLAN.LibVLC.TrackDescription
        //            .NativeToManagedMap[__ret];
        //    else __result0 = global::VideoLAN.LibVLC.TrackDescription.__CreateInstance(__ret);
        //    return __result0;
        //}

        ///// <summary>Set new video subtitle file.</summary>
        ///// <param name="p_mi">the media player</param>
        ///// <param name="psz_subtitle">new video subtitle file</param>
        ///// <returns>the success status (boolean)</returns>
        ///// <remarks>Use libvlc_media_player_add_slave() instead.</remarks>
        //public static int LibvlcVideoSetSubtitleFile(global::VideoLAN.LibVLC.MediaPlayer p_mi, string psz_subtitle)
        //{
        //    var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.NativeReference;
        //    var __ret = __Internal.LibvlcVideoSetSubtitleFile(__arg0, psz_subtitle);
        //    return __ret;
        //}

        /// <summary>Toggle teletext transparent status on video output.</summary>
        /// <param name="p_mi">the media player</param>
        /// <remarks>use libvlc_video_set_teletext() instead.</remarks>
        //public static void LibvlcToggleTeletext(global::VideoLAN.LibVLC.MediaPlayer p_mi)
        //{
        //    var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.NativeReference;
        //    __Internal.LibvlcToggleTeletext(__arg0);
        //}

        /// <summary>Backward compatibility stub. Do not use in new code.</summary>
        /// <returns>always 0.</returns>
        /// <remarks>Use libvlc_audio_output_device_list_get() instead.</remarks>
        public static int LibvlcAudioOutputDeviceCount(global::VideoLAN.LibVLC.Manual.Instance p_instance, string psz_audio_output)
        {
            var __arg0 = ReferenceEquals(p_instance, null) ? global::System.IntPtr.Zero : p_instance.NativeReference;
            var __ret = __Internal.LibvlcAudioOutputDeviceCount(__arg0, psz_audio_output);
            return __ret;
        }

        /// <summary>Backward compatibility stub. Do not use in new code.</summary>
        /// <returns>always NULL.</returns>
        /// <remarks>Use libvlc_audio_output_device_list_get() instead.</remarks>
        public static sbyte* LibvlcAudioOutputDeviceLongname(global::VideoLAN.LibVLC.Manual.Instance p_instance, string psz_output,
            int i_device)
        {
            var __arg0 = ReferenceEquals(p_instance, null) ? global::System.IntPtr.Zero : p_instance.NativeReference;
            var __ret = __Internal.LibvlcAudioOutputDeviceLongname(__arg0, psz_output, i_device);
            return __ret;
        }

        /// <summary>Backward compatibility stub. Do not use in new code.</summary>
        /// <returns>always NULL.</returns>
        /// <remarks>Use libvlc_audio_output_device_list_get() instead.</remarks>
        public static sbyte* LibvlcAudioOutputDeviceId(global::VideoLAN.LibVLC.Manual.Instance p_instance, string psz_audio_output,
            int i_device)
        {
            var __arg0 = ReferenceEquals(p_instance, null) ? global::System.IntPtr.Zero : p_instance.NativeReference;
            var __ret = __Internal.LibvlcAudioOutputDeviceId(__arg0, psz_audio_output, i_device);
            return __ret;
        }

        /// <summary>Stub for backward compatibility.</summary>
        /// <returns>always -1.</returns>
        //public static int LibvlcAudioOutputGetDeviceType(global::VideoLAN.LibVLC.MediaPlayer p_mi)
        //{
        //    var __arg0 = ReferenceEquals(p_mi, null) ? global::System.IntPtr.Zero : p_mi.__Instance;
        //    var __ret = __Internal.LibvlcAudioOutputGetDeviceType(__arg0);
        //    return __ret;
        //}

        ///// <summary>Stub for backward compatibility.</summary>
        //public static void LibvlcAudioOutputSetDeviceType(global::VideoLAN.LibVLC.MediaPlayer p_mp, int device_type)
        //{
        //    var __arg0 = ReferenceEquals(p_mp, null) ? global::System.IntPtr.Zero : p_mp.__Instance;
        //    __Internal.LibvlcAudioOutputSetDeviceType(__arg0, device_type);
        //}

    

        /// <summary>Get media descriptor's elementary streams description</summary>
        /// <param name="p_md">media descriptor object</param>
        /// <param name="tracks">
        /// <para>address to store an allocated array of Elementary Streams</para>
        /// <para>descriptions (must be freed by the caller) [OUT]</para>
        /// </param>
        /// <returns>the number of Elementary Streams</returns>
        /// <remarks>
        /// <para>Note, you need to call libvlc_media_parse() or play the media at least once</para>
        /// <para>before calling this function.</para>
        /// <para>Not doing this will result in an empty array.</para>
        /// <para>Use libvlc_media_tracks_get() instead</para>
        /// </remarks>
        public static int LibvlcMediaGetTracksInfo(global::VideoLAN.LibVLC.Media p_md,
            global::VideoLAN.LibVLC.MediaTrackInfo tracks)
        {
            var __arg0 = ReferenceEquals(p_md, null) ? global::System.IntPtr.Zero : p_md.NativeReference;
            var __arg1 = ReferenceEquals(tracks, null) ? global::System.IntPtr.Zero : tracks.__Instance;
            var __ret = __Internal.LibvlcMediaGetTracksInfo(__arg0, __arg1);
            return __ret;
        }

        /// <summary>@{</summary>
        public static int LibvlcMediaListAddFileContent(global::VideoLAN.LibVLC.MediaList p_ml, string psz_uri)
        {
            var __arg0 = ReferenceEquals(p_ml, null) ? global::System.IntPtr.Zero : p_ml.__Instance;
            var __ret = __Internal.LibvlcMediaListAddFileContent(__arg0, psz_uri);
            return __ret;
        }

        /// <remarks>Use libvlc_media_discoverer_new() and libvlc_media_discoverer_start().</remarks>
        public static global::VideoLAN.LibVLC.MediaDiscoverer LibvlcMediaDiscovererNewFromName(
            global::VideoLAN.LibVLC.Manual.Instance p_inst, string psz_name)
        {
            var __arg0 = ReferenceEquals(p_inst, null) ? global::System.IntPtr.Zero : p_inst.NativeReference;
            var __ret = __Internal.LibvlcMediaDiscovererNewFromName(__arg0, psz_name);
            global::VideoLAN.LibVLC.MediaDiscoverer __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::VideoLAN.LibVLC.MediaDiscoverer.NativeToManagedMap.ContainsKey(__ret))
                __result0 =
                    (global::VideoLAN.LibVLC.MediaDiscoverer) global::VideoLAN.LibVLC.MediaDiscoverer.NativeToManagedMap[__ret];
            else __result0 = global::VideoLAN.LibVLC.MediaDiscoverer.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>Get media service discover object its localized name.</summary>
        /// <param name="p_mdis">media discover object</param>
        /// <returns>localized name or NULL if the media_discoverer is not started</returns>
        /// <remarks>
        /// <para>Useless, use libvlc_media_discoverer_list_get() to get the</para>
        /// <para>longname of the service discovery.</para>
        /// </remarks>
        public static sbyte* LibvlcMediaDiscovererLocalizedName(global::VideoLAN.LibVLC.MediaDiscoverer p_mdis)
        {
            var __arg0 = ReferenceEquals(p_mdis, null) ? global::System.IntPtr.Zero : p_mdis.__Instance;
            var __ret = __Internal.LibvlcMediaDiscovererLocalizedName(__arg0);
            return __ret;
        }

        /// <summary>Get event manager from media service discover object.</summary>
        /// <param name="p_mdis">media service discover object</param>
        /// <returns>event manager object.</returns>
        /// <remarks>
        /// <para>Useless, media_discoverer events are only triggered when calling</para>
        /// <para>libvlc_media_discoverer_start() and libvlc_media_discoverer_stop().</para>
        /// </remarks>
        //public static global::VideoLAN.LibVLC.EventManager LibvlcMediaDiscovererEventManager(
        //    global::VideoLAN.LibVLC.MediaDiscoverer p_mdis)
        //{
        //    var __arg0 = ReferenceEquals(p_mdis, null) ? global::System.IntPtr.Zero : p_mdis.NativeReference;
        //    var __ret = __Internal.LibvlcMediaDiscovererEventManager(__arg0);
        //    global::VideoLAN.LibVLC.EventManager __result0;
        //    if (__ret == IntPtr.Zero) __result0 = null;
        //    else if (global::VideoLAN.LibVLC.EventManager.NativeToManagedMap.ContainsKey(__ret))
        //        __result0 =
        //            (global::VideoLAN.LibVLC.EventManager) global::VideoLAN.LibVLC.EventManager.NativeToManagedMap[__ret];
        //    else __result0 = global::VideoLAN.LibVLC.EventManager.__CreateInstance(__ret);
        //    return __result0;
        //}

        /// <summary>
        /// <para>Waits until an interface causes the instance to exit.</para>
        /// <para>You should start at least one interface first, using libvlc_add_intf().</para>
        /// </summary>
        /// <param name="p_instance">the instance</param>
        /// <remarks>
        /// <para>This function wastes one thread doing basically nothing.</para>
        /// <para>libvlc_set_exit_handler() should be used instead.</para>
        /// </remarks>
        public static void LibvlcWait(global::VideoLAN.LibVLC.Manual.Instance p_instance)
        {
            var __arg0 = ReferenceEquals(p_instance, null) ? global::System.IntPtr.Zero : p_instance.NativeReference;
            __Internal.LibvlcWait(__arg0);
        }

        /// <summary>
        /// <para>Always returns minus one.</para>
        /// <para>This function is only provided for backward compatibility.</para>
        /// </summary>
        /// <param name="p_instance">ignored</param>
        /// <returns>always -1</returns>
        public static uint LibvlcGetLogVerbosity(global::VideoLAN.LibVLC.Manual.Instance p_instance)
        {
            var __arg0 = ReferenceEquals(p_instance, null) ? global::System.IntPtr.Zero : p_instance.NativeReference;
            var __ret = __Internal.LibvlcGetLogVerbosity(__arg0);
            return __ret;
        }

        /// <summary>
        /// <para>This function does nothing.</para>
        /// <para>It is only provided for backward compatibility.</para>
        /// </summary>
        /// <param name="p_instance">ignored</param>
        /// <param name="level">ignored</param>
        public static void LibvlcSetLogVerbosity(global::VideoLAN.LibVLC.Manual.Instance p_instance, uint level)
        {
            var __arg0 = ReferenceEquals(p_instance, null) ? global::System.IntPtr.Zero : p_instance.NativeReference;
            __Internal.LibvlcSetLogVerbosity(__arg0, level);
        }

        /// <summary>
        /// <para>This function does nothing useful.</para>
        /// <para>It is only provided for backward compatibility.</para>
        /// </summary>
        /// <param name="p_instance">libvlc instance</param>
        /// <returns>an unique pointer or NULL on error</returns>
        public static global::VideoLAN.LibVLC.Log LibvlcLogOpen(global::VideoLAN.LibVLC.Manual.Instance p_instance)
        {
            var __arg0 = ReferenceEquals(p_instance, null) ? global::System.IntPtr.Zero : p_instance.NativeReference;
            var __ret = __Internal.LibvlcLogOpen(__arg0);
            global::VideoLAN.LibVLC.Log __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::VideoLAN.LibVLC.Log.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::VideoLAN.LibVLC.Log) global::VideoLAN.LibVLC.Log.NativeToManagedMap[__ret];
            else __result0 = global::VideoLAN.LibVLC.Log.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>Frees memory allocated by libvlc_log_open().</summary>
        /// <param name="p_log">libvlc log instance or NULL</param>
        public static void LibvlcLogClose(global::VideoLAN.LibVLC.Log p_log)
        {
            var __arg0 = ReferenceEquals(p_log, null) ? global::System.IntPtr.Zero : p_log.__Instance;
            __Internal.LibvlcLogClose(__arg0);
        }

        /// <summary>
        /// <para>Always returns zero.</para>
        /// <para>This function is only provided for backward compatibility.</para>
        /// </summary>
        /// <param name="p_log">ignored</param>
        /// <returns>always zero</returns>
        public static uint LibvlcLogCount(global::VideoLAN.LibVLC.Log p_log)
        {
            var __arg0 = ReferenceEquals(p_log, null) ? global::System.IntPtr.Zero : p_log.__Instance;
            var __ret = __Internal.LibvlcLogCount(__arg0);
            return __ret;
        }

        /// <summary>
        /// <para>This function does nothing.</para>
        /// <para>It is only provided for backward compatibility.</para>
        /// </summary>
        /// <param name="p_log">ignored</param>
        public static void LibvlcLogClear(global::VideoLAN.LibVLC.Log p_log)
        {
            var __arg0 = ReferenceEquals(p_log, null) ? global::System.IntPtr.Zero : p_log.__Instance;
            __Internal.LibvlcLogClear(__arg0);
        }

        /// <summary>
        /// <para>This function does nothing useful.</para>
        /// <para>It is only provided for backward compatibility.</para>
        /// </summary>
        /// <param name="p_log">ignored</param>
        /// <returns>an unique pointer or NULL on error or if the parameter was NULL</returns>
        public static global::VideoLAN.LibVLC.LogIterator LibvlcLogGetIterator(global::VideoLAN.LibVLC.Log p_log)
        {
            var __arg0 = ReferenceEquals(p_log, null) ? global::System.IntPtr.Zero : p_log.__Instance;
            var __ret = __Internal.LibvlcLogGetIterator(__arg0);
            global::VideoLAN.LibVLC.LogIterator __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::VideoLAN.LibVLC.LogIterator.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::VideoLAN.LibVLC.LogIterator) global::VideoLAN.LibVLC.LogIterator.NativeToManagedMap[__ret];
            else __result0 = global::VideoLAN.LibVLC.LogIterator.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>Frees memory allocated by libvlc_log_get_iterator().</summary>
        /// <param name="p_iter">libvlc log iterator or NULL</param>
        public static void LibvlcLogIteratorFree(global::VideoLAN.LibVLC.LogIterator p_iter)
        {
            var __arg0 = ReferenceEquals(p_iter, null) ? global::System.IntPtr.Zero : p_iter.__Instance;
            __Internal.LibvlcLogIteratorFree(__arg0);
        }

        /// <summary>
        /// <para>Always returns zero.</para>
        /// <para>This function is only provided for backward compatibility.</para>
        /// </summary>
        /// <param name="p_iter">ignored</param>
        /// <returns>always zero</returns>
        public static int LibvlcLogIteratorHasNext(global::VideoLAN.LibVLC.LogIterator p_iter)
        {
            var __arg0 = ReferenceEquals(p_iter, null) ? global::System.IntPtr.Zero : p_iter.__Instance;
            var __ret = __Internal.LibvlcLogIteratorHasNext(__arg0);
            return __ret;
        }

        /// <summary>
        /// <para>Always returns NULL.</para>
        /// <para>This function is only provided for backward compatibility.</para>
        /// </summary>
        /// <param name="p_iter">libvlc log iterator or NULL</param>
        /// <param name="p_buf">ignored</param>
        /// <returns>always NULL</returns>
        public static global::VideoLAN.LibVLC.LogMessage LibvlcLogIteratorNext(global::VideoLAN.LibVLC.LogIterator p_iter,
            global::VideoLAN.LibVLC.LogMessage p_buf)
        {
            var __arg0 = ReferenceEquals(p_iter, null) ? global::System.IntPtr.Zero : p_iter.__Instance;
            var __arg1 = ReferenceEquals(p_buf, null) ? global::System.IntPtr.Zero : p_buf.__Instance;
            var __ret = __Internal.LibvlcLogIteratorNext(__arg0, __arg1);
            global::VideoLAN.LibVLC.LogMessage __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::VideoLAN.LibVLC.LogMessage.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::VideoLAN.LibVLC.LogMessage) global::VideoLAN.LibVLC.LogMessage.NativeToManagedMap[__ret];
            else __result0 = global::VideoLAN.LibVLC.LogMessage.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>Start playing (if there is any item in the playlist).</summary>
        /// <param name="p_instance">the playlist instance</param>
        /// <param name="i_id">
        /// <para>the item to play. If this is a negative number, the next</para>
        /// <para>item will be selected. Otherwise, the item with the given ID will be</para>
        /// <para>played</para>
        /// </param>
        /// <param name="i_options">the number of options to add to the item</param>
        /// <param name="ppsz_options">the options to add to the item</param>
        /// <remarks>
        /// <para>Additionnal playlist item options can be specified for addition to the</para>
        /// <para>item before it is played.</para>
        /// </remarks>
        public static void LibvlcPlaylistPlay(global::VideoLAN.LibVLC.Manual.Instance p_instance, int i_id, int i_options,
            sbyte** ppsz_options)
        {
            var __arg0 = ReferenceEquals(p_instance, null) ? global::System.IntPtr.Zero : p_instance.NativeReference;
            __Internal.LibvlcPlaylistPlay(__arg0, i_id, i_options, ppsz_options);
        }
    }
}
